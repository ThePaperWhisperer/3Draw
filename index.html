<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DrawPaw - Free Drawing Online!</title>
    <style>
        body {
            overflow: hidden;
            margin: 0;
            padding: 0;
            height: 100%;
            background-color: black;
        }

        h1 {
            background: #7F7FD5;
            background: linear-gradient(to right, blue, green, orange);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        #drawing-board {
            border: 1px solid black;
            height: 100vh;
            width: 90vw;
            left: 10vw;
            background-color: white;
        }

        .container {
            height: 100%;
            display: flex;
        }

        #toolbar {
            display: flex;
            flex-direction: column;
            padding: 5px;
            width: 10vw;
            background-color: #202020;
        }

        #toolbar * {
            margin-bottom: 6px;
        }

        #toolbar label {
            font-size: 12px;
        }

        #toolbar input {
            width: 100%;
        }

        button {
            overflow: hidden;
        }

        #clear {
            background-color: #1565c0;
            border: none;
            border-radius: 4px;
            color: white;
            padding: 2px;
        }

        #erase {
            background-color: black;
            border: none;
            border-radius: 4px;
            color: white;
            padding: 2px;
        }

        #map {
            rotate: 1 0 0 20deg;
            position: absolute;
            left: 200px;
            top: -800px;
        }

        img {
            overflow: hidden;
        }
    </style>
</head>

<body>
    <section class="container">
        <div id="toolbar">
            <h1>DrawPaw</h1>
            <label for="stroke">Stroke</label>
            <input id="stroke" name='stroke' type="color">
            <button id="erase">Eraser</button>
            <label for="lineWidth">Brush Width</label>
            <input id="lineWidth" name='lineWidth' type="number" value="5">
            <button id="clear">Clear</button>
            <button id="oil"></button>
        </div>
        <div id="map"></div>
        <div class="drawing-board">
            <canvas id="drawing-board"></canvas>
        </div>
    </section>
    <script>
        var paintoil = new Image();
        paintoil.src = "oil.png";
        paintoil.style.width = "50px"
        paintoil.style.height = "50px"
        document.getElementById("oil").appendChild(paintoil);
        function recolorImage(img, newColor) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = 5000 + "px";
            canvas.height = 5000 + "px";
            ctx.drawImage(img, 0, 0);



            return canvas.toDataURL();
        }
        var offset = window.screen.width/10
        var lasttouch = null, touch;
        const oil = document.getElementById("oil");
        const canvas = document.getElementById('drawing-board');
        const toolbar = document.getElementById('toolbar');
        const eraser = document.getElementById('erase');
        const ctx = canvas.getContext('2d');

        const canvasOffsetX = canvas.offsetLeft;
        const canvasOffsetY = canvas.offsetTop;
        var color = "#000000";
        let isPainting = false;
        let lineWidth = 5;
        let startX;
        let startY;
        var isOil = true;
        toolbar.addEventListener('click', e => {
            if (e.target.id === 'clear') {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        });

        toolbar.addEventListener('change', e => {
            if (e.target.id === 'stroke') {
                ctx.strokeStyle = e.target.value;
                color = e.target.value;
            }

            if (e.target.id === 'lineWidth') {
                lineWidth = e.target.value;
            }

        });
        function shadeColor(color, amount) {
    return '#' + color.replace(/^#/, '').replace(/../g, color => ('0'+Math.min(255, Math.max(0, parseInt(color, 16) + amount)).toString(16)).substr(-2));
}
        function hexToRgb(hex) {
            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        
        const draw = (e) => {
            if (!isPainting) {
                return;
            }
            if (isOil) {
                if (lasttouch) {
                    for (let i = 0; i < 8* lineWidth/1.5; i+= lineWidth/1.5) {
                        if (i === 2* lineWidth/1.5 || i=== 4 * lineWidth/1.5) {
                            ctx.beginPath();
                                                        ctx.strokeStyle = shadeColor(color, -15);
                            ctx.lineWidth = lineWidth;
                            ctx.moveTo(lasttouch.clientX +i/Math.sqrt(5)- offset, lasttouch.clientY +i/Math.sqrt(5));
                            ctx.lineCap = 'round';
                            ctx.lineTo(e.clientX - offset+i/Math.sqrt(5), e.clientY +i/Math.sqrt(5));
                            ctx.stroke();
                            
                        }
                        else if (i === 5* lineWidth/1.5) {
                            ctx.beginPath();
                            ctx.strokeStyle = shadeColor(color, 40);
                            ctx.lineWidth = lineWidth/2;
                            ctx.moveTo(lasttouch.clientX +i/Math.sqrt(5)- offset, lasttouch.clientY +i/Math.sqrt(5));
                            ctx.lineCap = 'round';
                            ctx.lineTo(e.clientX - offset+i/Math.sqrt(5), e.clientY +i/Math.sqrt(5));
                            ctx.stroke();
                            
                        }
                        else {
                            ctx.beginPath();
                            ctx.strokeStyle = shadeColor(color, -5);
                            ctx.lineWidth = lineWidth;
                            ctx.moveTo(lasttouch.clientX +i/Math.sqrt(5)+lineWidth- offset,  lasttouch.clientY +i/Math.sqrt(5) +lineWidth);
                            ctx.lineCap = 'round';
                            ctx.lineTo(e.clientX - offset+i/Math.sqrt(5)+lineWidth , e.clientY +i/Math.sqrt(5)+lineWidth );
                            ctx.stroke();
                        }
                    }
                   
                }
                else {for (let i = 0; i < 8* lineWidth/1.5; i+= lineWidth/1.5) {
                        if (i === 2* lineWidth/1.5 || i=== 4 * lineWidth/1.5) {
                            ctx.beginPath();
                                                        ctx.strokeStyle = shadeColor(color, -15);
                            ctx.lineWidth = lineWidth;
                            ctx.lineCap = 'round';
                            ctx.lineTo(e.clientX - offset+i/Math.sqrt(5), e.clientY +i/Math.sqrt(5));
                            ctx.stroke();
                        }
                        else if (i === 5* lineWidth/1.5) {
                            ctx.beginPath();
                            ctx.strokeStyle = shadeColor(color, 40);
                            ctx.lineWidth = lineWidth/2;
                            ctx.moveTo(e.clientX +i/Math.sqrt(5)- offset, e.clientY +i/Math.sqrt(5));
                            ctx.lineCap = 'round';
                            ctx.lineTo(e.clientX - offset+i/Math.sqrt(5), e.clientY +i/Math.sqrt(5));
                            ctx.stroke();
                            
                        }
                        else {
                            ctx.beginPath();
                            ctx.strokeStyle = shadeColor(color, -5);
                            ctx.lineWidth = lineWidth;
                            ctx.lineCap = 'round';
                            ctx.lineTo(e.clientX - offset+i/Math.sqrt(5)+lineWidth, e.clientY +i/Math.sqrt(5)+lineWidth );
                            ctx.stroke();
                        }
                    }
                    
                }
                lasttouch = { clientX: e.clientX, clientY: e.clientY }

            }
            else {
                ctx.lineWidth = lineWidth;
                ctx.lineCap = 'round';
                ctx.lineTo(e.clientX - offset, e.clientY);
                ctx.stroke();
            }
        }
        const draw2 = (e) => {
            if (!isPainting) {
                return;
            }
            if (isOil) {


                if (lasttouch) {
                    for (let i = 0; i < 8* lineWidth/1.5; i+= lineWidth/1.5) {
                        if (i === 2* lineWidth/1.5 || i=== 4 * lineWidth/1.5) {
                            ctx.beginPath();
                                                        ctx.strokeStyle = shadeColor(color, -15);
                            ctx.lineWidth = lineWidth;
                            ctx.moveTo(lasttouch.clientX +i/Math.sqrt(5)- offset, lasttouch.clientY +i/Math.sqrt(5));
                            ctx.lineCap = 'round';
                            ctx.lineTo(e.touches[0].clientX - offset+i/Math.sqrt(5), e.touches[0].clientY +i/Math.sqrt(5));
                            ctx.stroke();
                        }
                        else if (i === 5* lineWidth/1.5) {
                            ctx.beginPath();
                            ctx.strokeStyle = shadeColor(color, 40);
                            ctx.lineWidth = lineWidth/2;
                            ctx.moveTo(lasttouch.clientX +i/Math.sqrt(5)- offset, lasttouch.clientY +i/Math.sqrt(5));
                            ctx.lineCap = 'round';
                            ctx.lineTo(e.touches[0].clientX - offset+i/Math.sqrt(5), e.touches[0].clientY +i/Math.sqrt(5));
                            ctx.stroke();
                            
                        }
                        else {
                            ctx.beginPath();
                            ctx.strokeStyle = shadeColor(color, -5);
                            ctx.lineWidth = lineWidth;
                            ctx.moveTo(lasttouch.clientX +i/Math.sqrt(5)+lineWidth- offset,  lasttouch.clientY +i/Math.sqrt(5) +lineWidth);
                            ctx.lineCap = 'round';
                            ctx.lineTo(e.touches[0].clientX - offset+i/Math.sqrt(5)+lineWidth , e.touches[0].clientY +i/Math.sqrt(5)+lineWidth );
                            ctx.stroke();
                        }
                    }
                   
                }
                else {
                    for (let i = 0; i < 8* lineWidth/1.5; i+= lineWidth/1.5) {
                        if (i === 2* lineWidth/1.5 || i=== 4 * lineWidth/1.5) {
                            ctx.beginPath();
                                                        ctx.strokeStyle = shadeColor(color, -15);
                            ctx.lineWidth = lineWidth;
                            ctx.lineCap = 'round';
                            ctx.lineTo(e.touches[0].clientX - offset+i/Math.sqrt(5), e.touches[0].clientY +i/Math.sqrt(5));
                            ctx.stroke();
                        }
                        else if (i === 5* lineWidth/1.5) {
                            ctx.beginPath();
                            ctx.strokeStyle = shadeColor(color, 40);
                            ctx.lineWidth = lineWidth/2;
                            ctx.moveTo(e.touches[0].clientX +i/Math.sqrt(5)- offset, e.touches[0].clientY +i/Math.sqrt(5));
                            ctx.lineCap = 'round';
                            ctx.lineTo(e.touches[0].clientX - offset+i/Math.sqrt(5), e.touches[0].clientY +i/Math.sqrt(5));
                            ctx.stroke();
                            
                        }
                        else {
                            ctx.beginPath();
                            ctx.strokeStyle = shadeColor(color, -5);
                            ctx.lineWidth = lineWidth;
                            ctx.lineCap = 'round';
                            ctx.lineTo(e.touches[0].clientX - offset+i/Math.sqrt(5)+lineWidth, e.touches[0].clientY +i/Math.sqrt(5)+lineWidth );
                            ctx.stroke();
                        }
                    }
                    
                }
                lasttouch = { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY }

            }
            else {
                ctx.lineWidth = lineWidth;
                ctx.lineCap = 'round';
                ctx.lineTo(e.touches[0].clientX- offset, e.touches[0].clientY);
                ctx.stroke();
            }
        }


        canvas.addEventListener('mousedown', (e) => {
            isPainting = true;
            startX = e.clientX;
            startY = e.clientY;
        });

        canvas.addEventListener('mouseup', e => {
            isPainting = false;
            ctx.stroke();
            ctx.beginPath();
        });
        canvas.addEventListener('touchstart', (e) => {
            isPainting = true;
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
        });
        canvas.addEventListener('touchend', e => {
            isPainting = false;
            ctx.stroke();
            ctx.beginPath();
        });
        function rgbaToHex(r, g, b, a) {
            const rHex = r.toString(16).padStart(2, '0');
            const gHex = g.toString(16).padStart(2, '0');
            const bHex = b.toString(16).padStart(2, '0');
            const aHex = a.toString(16).padStart(2, '0');
            return `#${rHex}${gHex}${bHex}${aHex}`;
        }
        canvas.addEventListener('touchmove', draw2);
        canvas.addEventListener('mousemove', draw);

        toolbar.addEventListener('click', e => {
            if (e.target.id === 'erase') {
                eraser.style.backgroundColor = "#b58691";
                ctx.strokeStyle = 'white';
            }
            if (e.target.id != 'erase' && eraser.style.backgroundColor === '#b58691') {
                eraser.style.backgroundColor = "black";
            }
        });
        oil.onclick = () => {
            if (!isOil) isOil = true;
            else isOil = false;
        }
    </script>
</body>

</html>